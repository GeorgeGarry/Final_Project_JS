{"ast":null,"code":"// Builder\n// -------\nconst assert = require('assert');\nconst {\n  EventEmitter\n} = require('events');\nconst assign = require('lodash/assign');\nconst clone = require('lodash/clone');\nconst each = require('lodash/each');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst last = require('lodash/last');\nconst reject = require('lodash/reject');\nconst tail = require('lodash/tail');\nconst toArray = require('lodash/toArray');\nconst {\n  addQueryContext,\n  normalizeArr\n} = require('../util/helpers');\nconst JoinClause = require('./joinclause');\nconst Analytic = require('./analytic');\nconst saveAsyncStack = require('../util/save-async-stack');\nconst {\n  isBoolean,\n  isNumber,\n  isObject,\n  isString,\n  isFunction\n} = require('../util/is');\nconst {\n  lockMode,\n  waitMode\n} = require('./constants');\nconst {\n  augmentWithBuilderInterface\n} = require('../builder-interface-augmenter');\nconst SELECT_COMMANDS = new Set(['pluck', 'first', 'select']);\nconst CLEARABLE_STATEMENTS = new Set(['with', 'select', 'columns', 'hintComments', 'where', 'union', 'join', 'group', 'order', 'having', 'limit', 'offset', 'counter', 'counters']);\nconst LOCK_MODES = new Set([lockMode.forShare, lockMode.forUpdate, lockMode.forNoKeyUpdate, lockMode.forKeyShare]);\n\n// Typically called from `knex.builder`,\n// start a new query building chain.\nclass Builder extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.and = this;\n    this._single = {};\n    this._comments = [];\n    this._statements = [];\n    this._method = 'select';\n    if (client.config) {\n      saveAsyncStack(this, 5);\n      this._debug = client.config.debug;\n    }\n    // Internal flags used in the builder.\n    this._joinFlag = 'inner';\n    this._boolFlag = 'and';\n    this._notFlag = false;\n    this._asColumnFlag = false;\n  }\n  toString() {\n    return this.toQuery();\n  }\n\n  // Convert the current query \"toSQL\"\n  toSQL(method, tz) {\n    return this.client.queryCompiler(this).toSQL(method || this._method, tz);\n  }\n\n  // Create a shallow clone of the current query builder.\n  clone() {\n    const cloned = new this.constructor(this.client);\n    cloned._method = this._method;\n    cloned._single = clone(this._single);\n    cloned._comments = clone(this._comments);\n    cloned._statements = clone(this._statements);\n    cloned._debug = this._debug;\n\n    // `_option` is assigned by the `Interface` mixin.\n    if (this._options !== undefined) {\n      cloned._options = clone(this._options);\n    }\n    if (this._queryContext !== undefined) {\n      cloned._queryContext = clone(this._queryContext);\n    }\n    if (this._connection !== undefined) {\n      cloned._connection = this._connection;\n    }\n    return cloned;\n  }\n  timeout(ms) {\n    let {\n      cancel\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (isNumber(ms) && ms > 0) {\n      this._timeout = ms;\n      if (cancel) {\n        this.client.assertCanCancelQuery();\n        this._cancelOnTimeout = true;\n      }\n    }\n    return this;\n  }\n\n  // With\n  // ------\n  isValidStatementArg(statement) {\n    return typeof statement === 'function' || statement instanceof Builder || statement && statement.isRawInstance;\n  }\n  _validateWithArgs(alias, statementOrColumnList, nothingOrStatement, method) {\n    const [query, columnList] = typeof nothingOrStatement === 'undefined' ? [statementOrColumnList, undefined] : [nothingOrStatement, statementOrColumnList];\n    if (typeof alias !== 'string') {\n      throw new Error(`${method}() first argument must be a string`);\n    }\n    if (this.isValidStatementArg(query) && typeof columnList === 'undefined') {\n      // Validated as two-arg variant (alias, statement).\n      return;\n    }\n\n    // Attempt to interpret as three-arg variant (alias, columnList, statement).\n    const isNonEmptyNameList = Array.isArray(columnList) && columnList.length > 0 && columnList.every(it => typeof it === 'string');\n    if (!isNonEmptyNameList) {\n      throw new Error(`${method}() second argument must be a statement or non-empty column name list.`);\n    }\n    if (this.isValidStatementArg(query)) {\n      return;\n    }\n    throw new Error(`${method}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`);\n  }\n  with(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(alias, statementOrColumnList, nothingOrStatement, 'with');\n    return this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n  }\n  withMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n  withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n\n  // Helper for compiling any advanced `with` queries.\n  withWrapped(alias, statementOrColumnList, nothingOrStatement, materialized) {\n    const [query, columnList] = typeof nothingOrStatement === 'undefined' ? [statementOrColumnList, undefined] : [nothingOrStatement, statementOrColumnList];\n    const statement = {\n      grouping: 'with',\n      type: 'withWrapped',\n      alias: alias,\n      columnList,\n      value: query\n    };\n    if (materialized !== undefined) {\n      statement.materialized = materialized;\n    }\n    this._statements.push(statement);\n    return this;\n  }\n\n  // With Recursive\n  // ------\n\n  withRecursive(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(alias, statementOrColumnList, nothingOrStatement, 'withRecursive');\n    return this.withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement);\n  }\n\n  // Helper for compiling any advanced `withRecursive` queries.\n  withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement) {\n    this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n    this._statements[this._statements.length - 1].recursive = true;\n    return this;\n  }\n\n  // Select\n  // ------\n\n  // Adds a column or columns to the list of \"columns\"\n  // being selected on the query.\n  columns(column) {\n    if (!column && column !== 0) return this;\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...arguments)\n    });\n    return this;\n  }\n\n  // Adds a comment to the query\n  comment(txt) {\n    if (!isString(txt)) {\n      throw new Error('Comment must be a string');\n    }\n    const forbiddenChars = ['/*', '*/', '?'];\n    if (forbiddenChars.some(chars => txt.includes(chars))) {\n      throw new Error(`Cannot include ${forbiddenChars.join(', ')} in comment`);\n    }\n    this._comments.push({\n      comment: txt\n    });\n    return this;\n  }\n\n  // Allow for a sub-select to be explicitly aliased as a column,\n  // without needing to compile the query in a where.\n  as(column) {\n    this._single.as = column;\n    return this;\n  }\n\n  // Adds a single hint or an array of hits to the list of \"hintComments\" on the query.\n  hintComment(hints) {\n    hints = Array.isArray(hints) ? hints : [hints];\n    if (hints.some(hint => !isString(hint))) {\n      throw new Error('Hint comment must be a string');\n    }\n    if (hints.some(hint => hint.includes('/*') || hint.includes('*/'))) {\n      throw new Error('Hint comment cannot include \"/*\" or \"*/\"');\n    }\n    if (hints.some(hint => hint.includes('?'))) {\n      throw new Error('Hint comment cannot include \"?\"');\n    }\n    this._statements.push({\n      grouping: 'hintComments',\n      value: hints\n    });\n    return this;\n  }\n\n  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.\n  withSchema(schemaName) {\n    this._single.schema = schemaName;\n    return this;\n  }\n\n  // Sets the `tableName` on the query.\n  // Alias to \"from\" for select and \"into\" for insert statements\n  // e.g. builder.insert({a: value}).into('tableName')\n  // `options`: options object containing keys:\n  //   - `only`: whether the query should use SQL's ONLY to not return\n  //           inheriting table data. Defaults to false.\n  table(tableName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._single.table = tableName;\n    this._single.only = options.only === true;\n    return this;\n  }\n\n  // Adds a `distinct` clause to the query.\n  distinct() {\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...arguments),\n      distinct: true\n    });\n    return this;\n  }\n  distinctOn() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (isEmpty(args)) {\n      throw new Error('distinctOn requires at least on argument');\n    }\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinctOn: true\n    });\n    return this;\n  }\n\n  // Adds a join clause to the query, allowing for advanced joins\n  // with an anonymous function as the second argument.\n  join(table, first) {\n    let join;\n    const schema = table instanceof Builder || typeof table === 'function' ? undefined : this._single.schema;\n    const joinType = this._joinType();\n    if (typeof first === 'function') {\n      join = new JoinClause(table, joinType, schema);\n      first.call(join, join);\n    } else if (joinType === 'raw') {\n      join = new JoinClause(this.client.raw(table, first), 'raw');\n    } else {\n      join = new JoinClause(table, joinType, schema);\n      if (first) {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          args[_key2 - 2] = arguments[_key2];\n        }\n        join.on(first, ...args);\n      }\n    }\n    this._statements.push(join);\n    return this;\n  }\n  using(tables) {\n    throw new Error(\"'using' function is only available in PostgreSQL dialect with Delete statements.\");\n  }\n\n  // JOIN blocks:\n  innerJoin() {\n    return this._joinType('inner').join(...arguments);\n  }\n  leftJoin() {\n    return this._joinType('left').join(...arguments);\n  }\n  leftOuterJoin() {\n    return this._joinType('left outer').join(...arguments);\n  }\n  rightJoin() {\n    return this._joinType('right').join(...arguments);\n  }\n  rightOuterJoin() {\n    return this._joinType('right outer').join(...arguments);\n  }\n  outerJoin() {\n    return this._joinType('outer').join(...arguments);\n  }\n  fullOuterJoin() {\n    return this._joinType('full outer').join(...arguments);\n  }\n  crossJoin() {\n    return this._joinType('cross').join(...arguments);\n  }\n  joinRaw() {\n    return this._joinType('raw').join(...arguments);\n  }\n\n  // Where modifiers:\n  get or() {\n    return this._bool('or');\n  }\n  get not() {\n    return this._not(true);\n  }\n\n  // The where function can be used in several ways:\n  // The most basic is `where(key, value)`, which expands to\n  // where key = value.\n  where(column, operator, value) {\n    const argsLength = arguments.length;\n\n    // Support \"where true || where false\"\n    if (column === false || column === true) {\n      return this.where(1, '=', column ? 1 : 0);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a where statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.whereWrapped(column);\n    }\n\n    // Allows `where({id: 2})` syntax.\n    if (isObject(column) && !column.isRawInstance) return this._objectWhere(column);\n\n    // Allow a raw statement to be passed along to the query.\n    if (column && column.isRawInstance && argsLength === 1) return this.whereRaw(column);\n\n    // Enable the where('key', value) syntax, only when there\n    // are explicitly two arguments passed, so it's not possible to\n    // do where('key', '!=') and have that turn into where key != null\n    if (argsLength === 2) {\n      value = operator;\n      operator = '=';\n\n      // If the value is null, and it's a two argument query,\n      // we assume we're going for a `whereNull`.\n      if (value === null) {\n        return this.whereNull(column);\n      }\n    }\n\n    // lower case the operator for comparison purposes\n    const checkOperator = `${operator}`.toLowerCase().trim();\n\n    // If there are 3 arguments, check whether 'in' is one of them.\n    if (argsLength === 3) {\n      if (checkOperator === 'in' || checkOperator === 'not in') {\n        return this._not(checkOperator === 'not in').whereIn(column, value);\n      }\n      if (checkOperator === 'between' || checkOperator === 'not between') {\n        return this._not(checkOperator === 'not between').whereBetween(column, value);\n      }\n    }\n\n    // If the value is still null, check whether they're meaning\n    // where value is null\n    if (value === null) {\n      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');\n      if (checkOperator === 'is' || checkOperator === 'is not') {\n        return this._not(checkOperator === 'is not').whereNull(column);\n      }\n    }\n\n    // Push onto the where statement stack.\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBasic',\n      column,\n      operator,\n      value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    });\n    return this;\n  }\n  whereColumn() {\n    this._asColumnFlag = true;\n    this.where(...arguments);\n    this._asColumnFlag = false;\n    return this;\n  }\n\n  // Adds an `or where` clause to the query.\n  orWhere(column) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhere(key, obj[key]);\n        }\n      });\n    }\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return this.where(column, ...args);\n  }\n  orWhereColumn(column) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhereColumn(key, '=', obj[key]);\n        }\n      });\n    }\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    return this.whereColumn(column, ...args);\n  }\n\n  // Adds an `not where` clause to the query.\n  whereNot(column) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n    if (args.length >= 2) {\n      if (args[0] === 'in' || args[0] === 'between') {\n        this.client.logger.warn('whereNot is not suitable for \"in\" and \"between\" type subqueries. You should use \"not in\" and \"not between\" instead.');\n      }\n    }\n    return this._not(true).where(column, ...args);\n  }\n  whereNotColumn() {\n    return this._not(true).whereColumn(...arguments);\n  }\n\n  // Adds an `or not where` clause to the query.\n  orWhereNot() {\n    return this._bool('or').whereNot(...arguments);\n  }\n  orWhereNotColumn() {\n    return this._bool('or').whereNotColumn(...arguments);\n  }\n\n  // Processes an object literal provided in a \"where\" clause.\n  _objectWhere(obj) {\n    const boolVal = this._bool();\n    const notVal = this._not() ? 'Not' : '';\n    for (const key in obj) {\n      this[boolVal + 'Where' + notVal](key, obj[key]);\n    }\n    return this;\n  }\n\n  // Adds a raw `where` clause to the query.\n  whereRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereRaw',\n      value: raw,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orWhereRaw(sql, bindings) {\n    return this._bool('or').whereRaw(sql, bindings);\n  }\n\n  // Helper for compiling any advanced `where` queries.\n  whereWrapped(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereWrapped',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `where exists` clause to the query.\n  whereExists(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds an `or where exists` clause to the query.\n  orWhereExists(callback) {\n    return this._bool('or').whereExists(callback);\n  }\n\n  // Adds a `where not exists` clause to the query.\n  whereNotExists(callback) {\n    return this._not(true).whereExists(callback);\n  }\n\n  // Adds a `or where not exists` clause to the query.\n  orWhereNotExists(callback) {\n    return this._bool('or').whereNotExists(callback);\n  }\n\n  // Adds a `where in` clause to the query.\n  whereIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values)) return this.where(this._not());\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orWhereIn(column, values) {\n    return this._bool('or').whereIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  whereNotIn(column, values) {\n    return this._not(true).whereIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orWhereNotIn(column, values) {\n    return this._bool('or')._not(true).whereIn(column, values);\n  }\n\n  // Adds a `where null` clause to the query.\n  whereNull(column) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereNull',\n      column,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `or where null` clause to the query.\n  orWhereNull(column) {\n    return this._bool('or').whereNull(column);\n  }\n\n  // Adds a `where not null` clause to the query.\n  whereNotNull(column) {\n    return this._not(true).whereNull(column);\n  }\n\n  // Adds a `or where not null` clause to the query.\n  orWhereNotNull(column) {\n    return this._bool('or').whereNotNull(column);\n  }\n\n  // Adds a `where between` clause to the query.\n  whereBetween(column, values) {\n    assert(Array.isArray(values), 'The second argument to whereBetween must be an array.');\n    assert(values.length === 2, 'You must specify 2 values for the whereBetween clause');\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `where not between` clause to the query.\n  whereNotBetween(column, values) {\n    return this._not(true).whereBetween(column, values);\n  }\n\n  // Adds a `or where between` clause to the query.\n  orWhereBetween(column, values) {\n    return this._bool('or').whereBetween(column, values);\n  }\n\n  // Adds a `or where not between` clause to the query.\n  orWhereNotBetween(column, values) {\n    return this._bool('or').whereNotBetween(column, values);\n  }\n  _whereLike(type, column, value) {\n    this._statements.push({\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    });\n    return this;\n  }\n\n  // Adds a `where like` clause to the query.\n  whereLike(column, value) {\n    return this._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `or where like` clause to the query.\n  orWhereLike(column, value) {\n    return this._bool('or')._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `where ilike` clause to the query.\n  whereILike(column, value) {\n    return this._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `or where ilike` clause to the query.\n  orWhereILike(column, value) {\n    return this._bool('or')._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `group by` clause to the query.\n  groupBy(item) {\n    if (item && item.isRawInstance) {\n      return this.groupByRaw.apply(this, arguments);\n    }\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByBasic',\n      value: normalizeArr(...arguments)\n    });\n    return this;\n  }\n\n  // Adds a raw `group by` clause to the query.\n  groupByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByRaw',\n      value: raw\n    });\n    return this;\n  }\n\n  // Adds a `order by` clause to the query.\n  orderBy(column, direction) {\n    let nulls = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    if (Array.isArray(column)) {\n      return this._orderByArray(column);\n    }\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByBasic',\n      value: column,\n      direction,\n      nulls\n    });\n    return this;\n  }\n\n  // Adds a `order by` with multiple columns to the query.\n  _orderByArray(columnDefs) {\n    for (let i = 0; i < columnDefs.length; i++) {\n      const columnInfo = columnDefs[i];\n      if (isObject(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo['column'],\n          direction: columnInfo['order'],\n          nulls: columnInfo['nulls']\n        });\n      } else if (isString(columnInfo) || isNumber(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo\n        });\n      }\n    }\n    return this;\n  }\n\n  // Add a raw `order by` clause to the query.\n  orderByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByRaw',\n      value: raw\n    });\n    return this;\n  }\n  _union(clause, args) {\n    let callbacks = args[0];\n    let wrap = args[1];\n    if (args.length === 1 || args.length === 2 && isBoolean(wrap)) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: clause,\n          value: callbacks[i],\n          wrap: wrap || false\n        });\n      }\n    } else {\n      callbacks = toArray(args).slice(0, args.length - 1);\n      wrap = args[args.length - 1];\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n      this._union(clause, [callbacks, wrap]);\n    }\n    return this;\n  }\n\n  // Add a union statement to the query.\n  union() {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    return this._union('union', args);\n  }\n\n  // Adds a union all statement to the query.\n  unionAll() {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    return this._union('union all', args);\n  }\n  intersect() {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    return this._union('intersect', args);\n  }\n  except() {\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    return this._union('except', args);\n  }\n\n  // Adds a `having` clause to the query.\n  having(column, operator, value) {\n    if (column.isRawInstance && arguments.length === 1) {\n      return this.havingRaw(column);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a having statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.havingWrapped(column);\n    }\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBasic',\n      column,\n      operator,\n      value,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  }\n  orHaving(column) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.havingWrapped(function () {\n        for (const key in obj) {\n          this.andHaving(key, obj[key]);\n        }\n      });\n    }\n    for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n      args[_key10 - 1] = arguments[_key10];\n    }\n    return this.having(column, ...args);\n  }\n\n  // Helper for compiling any advanced `having` queries.\n  havingWrapped(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingWrapped',\n      value: callback,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  }\n  havingNull(column) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingNull',\n      column,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orHavingNull(callback) {\n    return this._bool('or').havingNull(callback);\n  }\n  havingNotNull(callback) {\n    return this._not(true).havingNull(callback);\n  }\n  orHavingNotNull(callback) {\n    return this._not(true)._bool('or').havingNull(callback);\n  }\n  havingExists(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orHavingExists(callback) {\n    return this._bool('or').havingExists(callback);\n  }\n  havingNotExists(callback) {\n    return this._not(true).havingExists(callback);\n  }\n  orHavingNotExists(callback) {\n    return this._not(true)._bool('or').havingExists(callback);\n  }\n  havingBetween(column, values) {\n    assert(Array.isArray(values), 'The second argument to havingBetween must be an array.');\n    assert(values.length === 2, 'You must specify 2 values for the havingBetween clause');\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orHavingBetween(column, values) {\n    return this._bool('or').havingBetween(column, values);\n  }\n  havingNotBetween(column, values) {\n    return this._not(true).havingBetween(column, values);\n  }\n  orHavingNotBetween(column, values) {\n    return this._not(true)._bool('or').havingBetween(column, values);\n  }\n  havingIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values)) return this.where(this._not());\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orHavingIn(column, values) {\n    return this._bool('or').havingIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  havingNotIn(column, values) {\n    return this._not(true).havingIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orHavingNotIn(column, values) {\n    return this._bool('or')._not(true).havingIn(column, values);\n  }\n\n  // Adds a raw `having` clause to the query.\n  havingRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingRaw',\n      value: raw,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  }\n  orHavingRaw(sql, bindings) {\n    return this._bool('or').havingRaw(sql, bindings);\n  }\n\n  // set the skip binding parameter (= insert the raw value in the query) for an attribute.\n  _setSkipBinding(attribute, options) {\n    let skipBinding = options;\n    if (isObject(options)) {\n      skipBinding = options.skipBinding;\n    }\n    this._single.skipBinding = this._single.skipBinding || {};\n    this._single.skipBinding[attribute] = skipBinding;\n  }\n\n  // Only allow a single \"offset\" to be set for the current query.\n  offset(value, options) {\n    if (value == null || value.isRawInstance || value instanceof Builder) {\n      // Builder for backward compatibility\n      this._single.offset = value;\n    } else {\n      const val = parseInt(value, 10);\n      if (isNaN(val)) {\n        this.client.logger.warn('A valid integer must be provided to offset');\n      } else if (val < 0) {\n        throw new Error(`A non-negative integer must be provided to offset.`);\n      } else {\n        this._single.offset = val;\n      }\n    }\n    this._setSkipBinding('offset', options);\n    return this;\n  }\n\n  // Only allow a single \"limit\" to be set for the current query.\n  limit(value, options) {\n    const val = parseInt(value, 10);\n    if (isNaN(val)) {\n      this.client.logger.warn('A valid integer must be provided to limit');\n    } else {\n      this._single.limit = val;\n      this._setSkipBinding('limit', options);\n    }\n    return this;\n  }\n\n  // Retrieve the \"count\" result of the query.\n  count(column, options) {\n    return this._aggregate('count', column || '*', options);\n  }\n\n  // Retrieve the minimum value of a given column.\n  min(column, options) {\n    return this._aggregate('min', column, options);\n  }\n\n  // Retrieve the maximum value of a given column.\n  max(column, options) {\n    return this._aggregate('max', column, options);\n  }\n\n  // Retrieve the sum of the values of a given column.\n  sum(column, options) {\n    return this._aggregate('sum', column, options);\n  }\n\n  // Retrieve the average of the values of a given column.\n  avg(column, options) {\n    return this._aggregate('avg', column, options);\n  }\n\n  // Retrieve the \"count\" of the distinct results of the query.\n  countDistinct() {\n    for (var _len11 = arguments.length, columns = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      columns[_key11] = arguments[_key11];\n    }\n    let options;\n    if (columns.length > 1 && isPlainObject(last(columns))) {\n      [options] = columns.splice(columns.length - 1, 1);\n    }\n    if (!columns.length) {\n      columns = '*';\n    } else if (columns.length === 1) {\n      columns = columns[0];\n    }\n    return this._aggregate('count', columns, {\n      ...options,\n      distinct: true\n    });\n  }\n\n  // Retrieve the sum of the distinct values of a given column.\n  sumDistinct(column, options) {\n    return this._aggregate('sum', column, {\n      ...options,\n      distinct: true\n    });\n  }\n\n  // Retrieve the vg of the distinct results of the query.\n  avgDistinct(column, options) {\n    return this._aggregate('avg', column, {\n      ...options,\n      distinct: true\n    });\n  }\n\n  // Increments a column's value by the specified amount.\n  increment(column) {\n    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, column[key]);\n      }\n      return this;\n    }\n    return this._counter(column, amount);\n  }\n\n  // Decrements a column's value by the specified amount.\n  decrement(column) {\n    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, -column[key]);\n      }\n      return this;\n    }\n    return this._counter(column, -amount);\n  }\n\n  // Clears increments/decrements\n  clearCounters() {\n    this._single.counter = {};\n    return this;\n  }\n\n  // Sets the values for a `select` query, informing that only the first\n  // row should be returned (limit 1).\n  first() {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .first() on \"${this._method}\" query`);\n    }\n    this.select(normalizeArr(...arguments));\n    this._method = 'first';\n    this.limit(1);\n    return this;\n  }\n\n  // Use existing connection to execute the query\n  // Same value that client.acquireConnection() for an according client returns should be passed\n  connection(_connection) {\n    this._connection = _connection;\n    this.client.processPassedConnection(_connection);\n    return this;\n  }\n\n  // Pluck a column from a query.\n  pluck(column) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .pluck() on \"${this._method}\" query`);\n    }\n    this._method = 'pluck';\n    this._single.pluck = column;\n    this._statements.push({\n      grouping: 'columns',\n      type: 'pluck',\n      value: column\n    });\n    return this;\n  }\n\n  // Deprecated. Remove everything from select clause\n  clearSelect() {\n    this._clearGrouping('columns');\n    return this;\n  }\n\n  // Deprecated. Remove everything from where clause\n  clearWhere() {\n    this._clearGrouping('where');\n    return this;\n  }\n\n  // Deprecated. Remove everything from group clause\n  clearGroup() {\n    this._clearGrouping('group');\n    return this;\n  }\n\n  // Deprecated. Remove everything from order clause\n  clearOrder() {\n    this._clearGrouping('order');\n    return this;\n  }\n\n  // Deprecated. Remove everything from having clause\n  clearHaving() {\n    this._clearGrouping('having');\n    return this;\n  }\n\n  // Remove everything from statement clause\n  clear(statement) {\n    if (!CLEARABLE_STATEMENTS.has(statement)) throw new Error(`Knex Error: unknown statement '${statement}'`);\n    if (statement.startsWith('counter')) return this.clearCounters();\n    if (statement === 'select') {\n      statement = 'columns';\n    }\n    this._clearGrouping(statement);\n    return this;\n  }\n\n  // Insert & Update\n  // ------\n\n  // Sets the values for an `insert` query.\n  insert(values, returning, options) {\n    this._method = 'insert';\n    if (!isEmpty(returning)) this.returning(returning, options);\n    this._single.insert = values;\n    return this;\n  }\n\n  // Sets the values for an `update`, allowing for both\n  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.\n  update(values, returning, options) {\n    let ret;\n    const obj = this._single.update || {};\n    this._method = 'update';\n    if (isString(values)) {\n      if (isPlainObject(returning)) {\n        obj[values] = JSON.stringify(returning);\n      } else {\n        obj[values] = returning;\n      }\n      if (arguments.length > 2) {\n        ret = arguments[2];\n      }\n    } else {\n      const keys = Object.keys(values);\n      if (this._single.update) {\n        this.client.logger.warn('Update called multiple times with objects.');\n      }\n      let i = -1;\n      while (++i < keys.length) {\n        obj[keys[i]] = values[keys[i]];\n      }\n      ret = arguments[1];\n    }\n    if (!isEmpty(ret)) this.returning(ret, options);\n    this._single.update = obj;\n    return this;\n  }\n\n  // Sets the returning value for the query.\n  returning(returning, options) {\n    this._single.returning = returning;\n    this._single.options = options;\n    return this;\n  }\n  onConflict(columns) {\n    if (typeof columns === 'string') {\n      columns = [columns];\n    }\n    return new OnConflictBuilder(this, columns || true);\n  }\n\n  // Delete\n  // ------\n\n  // Executes a delete statement on the query;\n  delete(ret, options) {\n    this._method = 'del';\n    if (!isEmpty(ret)) this.returning(ret, options);\n    return this;\n  }\n\n  // Truncates a table, ends the query chain.\n  truncate(tableName) {\n    this._method = 'truncate';\n    if (tableName) {\n      this._single.table = tableName;\n    }\n    return this;\n  }\n\n  // Retrieves columns for the table specified by `knex(tableName)`\n  columnInfo(column) {\n    this._method = 'columnInfo';\n    this._single.columnInfo = column;\n    return this;\n  }\n\n  // Set a lock for update constraint.\n  forUpdate() {\n    this._single.lock = lockMode.forUpdate;\n    for (var _len12 = arguments.length, tables = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      tables[_key12] = arguments[_key12];\n    }\n    if (tables.length === 1 && Array.isArray(tables[0])) {\n      this._single.lockTables = tables[0];\n    } else {\n      this._single.lockTables = tables;\n    }\n    return this;\n  }\n\n  // Set a lock for share constraint.\n  forShare() {\n    this._single.lock = lockMode.forShare;\n    for (var _len13 = arguments.length, tables = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      tables[_key13] = arguments[_key13];\n    }\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for no key update constraint.\n  forNoKeyUpdate() {\n    this._single.lock = lockMode.forNoKeyUpdate;\n    for (var _len14 = arguments.length, tables = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n      tables[_key14] = arguments[_key14];\n    }\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for key share constraint.\n  forKeyShare() {\n    this._single.lock = lockMode.forKeyShare;\n    for (var _len15 = arguments.length, tables = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n      tables[_key15] = arguments[_key15];\n    }\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Skips locked rows when using a lock constraint.\n  skipLocked() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .skipLocked() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error('.skipLocked() can only be used after a call to .forShare() or .forUpdate()!');\n    }\n    if (this._single.waitMode === waitMode.noWait) {\n      throw new Error('.skipLocked() cannot be used together with .noWait()!');\n    }\n    this._single.waitMode = waitMode.skipLocked;\n    return this;\n  }\n\n  // Causes error when acessing a locked row instead of waiting for it to be released.\n  noWait() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .noWait() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error('.noWait() can only be used after a call to .forShare() or .forUpdate()!');\n    }\n    if (this._single.waitMode === waitMode.skipLocked) {\n      throw new Error('.noWait() cannot be used together with .skipLocked()!');\n    }\n    this._single.waitMode = waitMode.noWait;\n    return this;\n  }\n\n  // Takes a JS object of methods to call and calls them\n  fromJS(obj) {\n    each(obj, (val, key) => {\n      if (typeof this[key] !== 'function') {\n        this.client.logger.warn(`Knex Error: unknown key ${key}`);\n      }\n      if (Array.isArray(val)) {\n        this[key].apply(this, val);\n      } else {\n        this[key](val);\n      }\n    });\n    return this;\n  }\n  fromRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    return this.from(raw);\n  }\n\n  // Passes query to provided callback function, useful for e.g. composing\n  // domain-specific helpers\n  modify(callback) {\n    callback.apply(this, [this].concat(tail(arguments)));\n    return this;\n  }\n  upsert(values, returning, options) {\n    throw new Error(`Upsert is not yet supported for dialect ${this.client.dialect}`);\n  }\n\n  // JSON support functions\n  _json(nameFunction, params) {\n    this._statements.push({\n      grouping: 'columns',\n      type: 'json',\n      method: nameFunction,\n      params: params\n    });\n    return this;\n  }\n  jsonExtract() {\n    const column = arguments[0];\n    let path;\n    let alias;\n    let singleValue = true;\n\n    // We use arguments to have the signatures :\n    // - column (string or array)\n    // - column + path\n    // - column + path + alias\n    // - column + path + alias + singleValue\n    // - column array + singleValue\n    if (arguments.length >= 2) {\n      path = arguments[1];\n    }\n    if (arguments.length >= 3) {\n      alias = arguments[2];\n    }\n    if (arguments.length === 4) {\n      singleValue = arguments[3];\n    }\n    if (arguments.length === 2 && Array.isArray(arguments[0]) && isBoolean(arguments[1])) {\n      singleValue = arguments[1];\n    }\n    return this._json('jsonExtract', {\n      column: column,\n      path: path,\n      alias: alias,\n      singleValue // boolean used only in MSSQL to use function for extract value instead of object/array.\n    });\n  }\n\n  jsonSet(column, path, value, alias) {\n    return this._json('jsonSet', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias\n    });\n  }\n  jsonInsert(column, path, value, alias) {\n    return this._json('jsonInsert', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias\n    });\n  }\n  jsonRemove(column, path, alias) {\n    return this._json('jsonRemove', {\n      column: column,\n      path: path,\n      alias: alias\n    });\n  }\n\n  // Wheres for JSON\n  _isJsonObject(jsonValue) {\n    return isObject(jsonValue) && !(jsonValue instanceof Builder);\n  }\n  _whereJsonWrappedValue(type, column, value) {\n    const whereJsonClause = {\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    };\n    if (arguments[3]) {\n      whereJsonClause.operator = arguments[3];\n    }\n    if (arguments[4]) {\n      whereJsonClause.jsonPath = arguments[4];\n    }\n    this._statements.push(whereJsonClause);\n  }\n  whereJsonObject(column, value) {\n    this._whereJsonWrappedValue('whereJsonObject', column, value);\n    return this;\n  }\n  orWhereJsonObject(column, value) {\n    return this._bool('or').whereJsonObject(column, value);\n  }\n  whereNotJsonObject(column, value) {\n    return this._not(true).whereJsonObject(column, value);\n  }\n  orWhereNotJsonObject(column, value) {\n    return this._bool('or').whereNotJsonObject(column, value);\n  }\n  whereJsonPath(column, path, operator, value) {\n    this._whereJsonWrappedValue('whereJsonPath', column, value, operator, path);\n    return this;\n  }\n  orWhereJsonPath(column, path, operator, value) {\n    return this._bool('or').whereJsonPath(column, path, operator, value);\n  }\n\n  // Json superset wheres\n  whereJsonSupersetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSupersetOf', column, value);\n    return this;\n  }\n  whereJsonNotSupersetOf(column, value) {\n    return this._not(true).whereJsonSupersetOf(column, value);\n  }\n  orWhereJsonSupersetOf(column, value) {\n    return this._bool('or').whereJsonSupersetOf(column, value);\n  }\n  orWhereJsonNotSupersetOf(column, value) {\n    return this._bool('or').whereJsonNotSupersetOf(column, value);\n  }\n\n  // Json subset wheres\n  whereJsonSubsetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSubsetOf', column, value);\n    return this;\n  }\n  whereJsonNotSubsetOf(column, value) {\n    return this._not(true).whereJsonSubsetOf(column, value);\n  }\n  orWhereJsonSubsetOf(column, value) {\n    return this._bool('or').whereJsonSubsetOf(column, value);\n  }\n  orWhereJsonNotSubsetOf(column, value) {\n    return this._bool('or').whereJsonNotSubsetOf(column, value);\n  }\n  whereJsonHasNone(column, values) {\n    this._not(true).whereJsonHasAll(column, values);\n    return this;\n  }\n\n  // end of wheres for JSON\n\n  _analytic(alias, second, third) {\n    let analytic;\n    const {\n      schema\n    } = this._single;\n    const method = this._analyticMethod();\n    alias = typeof alias === 'string' ? alias : null;\n    assert(typeof second === 'function' || second.isRawInstance || Array.isArray(second) || typeof second === 'string' || typeof second === 'object', `The second argument to an analytic function must be either a function, a raw,\n       an array of string or object, an object or a single string.`);\n    if (third) {\n      assert(Array.isArray(third) || typeof third === 'string' || typeof third === 'object', 'The third argument to an analytic function must be either a string, an array of string or object or an object.');\n    }\n    if (isFunction(second)) {\n      analytic = new Analytic(method, schema, alias);\n      second.call(analytic, analytic);\n    } else if (second.isRawInstance) {\n      const raw = second;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        raw: raw,\n        alias: alias\n      };\n    } else {\n      const order = !Array.isArray(second) ? [second] : second;\n      let partitions = third || [];\n      partitions = !Array.isArray(partitions) ? [partitions] : partitions;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        order: order,\n        alias: alias,\n        partitions: partitions\n      };\n    }\n    this._statements.push(analytic);\n    return this;\n  }\n  rank() {\n    return this._analyticMethod('rank')._analytic(...arguments);\n  }\n  denseRank() {\n    return this._analyticMethod('dense_rank')._analytic(...arguments);\n  }\n  rowNumber() {\n    return this._analyticMethod('row_number')._analytic(...arguments);\n  }\n\n  // ----------------------------------------------------------------------\n\n  // Helper for the incrementing/decrementing queries.\n  _counter(column, amount) {\n    amount = parseFloat(amount);\n    this._method = 'update';\n    this._single.counter = this._single.counter || {};\n    this._single.counter[column] = amount;\n    return this;\n  }\n\n  // Helper to get or set the \"boolFlag\" value.\n  _bool(val) {\n    if (arguments.length === 1) {\n      this._boolFlag = val;\n      return this;\n    }\n    const ret = this._boolFlag;\n    this._boolFlag = 'and';\n    return ret;\n  }\n\n  // Helper to get or set the \"notFlag\" value.\n  _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n    const ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  }\n\n  // Helper to get or set the \"joinFlag\" value.\n  _joinType(val) {\n    if (arguments.length === 1) {\n      this._joinFlag = val;\n      return this;\n    }\n    const ret = this._joinFlag || 'inner';\n    this._joinFlag = 'inner';\n    return ret;\n  }\n  _analyticMethod(val) {\n    if (arguments.length === 1) {\n      this._analyticFlag = val;\n      return this;\n    }\n    return this._analyticFlag || 'row_number';\n  }\n\n  // Helper for compiling any aggregate queries.\n  _aggregate(method, column) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this._statements.push({\n      grouping: 'columns',\n      type: column.isRawInstance ? 'aggregateRaw' : 'aggregate',\n      method,\n      value: column,\n      aggregateDistinct: options.distinct || false,\n      alias: options.as\n    });\n    return this;\n  }\n\n  // Helper function for clearing or reseting a grouping type from the builder\n  _clearGrouping(grouping) {\n    if (grouping in this._single) {\n      this._single[grouping] = undefined;\n    } else {\n      this._statements = reject(this._statements, {\n        grouping\n      });\n    }\n  }\n\n  // Helper function that checks if the builder will emit a select query\n  _isSelectQuery() {\n    return SELECT_COMMANDS.has(this._method);\n  }\n\n  // Helper function that checks if the query has a lock mode set\n  _hasLockMode() {\n    return LOCK_MODES.has(this._single.lock);\n  }\n}\nBuilder.prototype.select = Builder.prototype.columns;\nBuilder.prototype.column = Builder.prototype.columns;\nBuilder.prototype.andWhereNot = Builder.prototype.whereNot;\nBuilder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;\nBuilder.prototype.andWhere = Builder.prototype.where;\nBuilder.prototype.andWhereColumn = Builder.prototype.whereColumn;\nBuilder.prototype.andWhereRaw = Builder.prototype.whereRaw;\nBuilder.prototype.andWhereBetween = Builder.prototype.whereBetween;\nBuilder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;\nBuilder.prototype.andWhereJsonObject = Builder.prototype.whereJsonObject;\nBuilder.prototype.andWhereNotJsonObject = Builder.prototype.whereJsonObject;\nBuilder.prototype.andWhereJsonPath = Builder.prototype.whereJsonPath;\nBuilder.prototype.andWhereLike = Builder.prototype.whereLike;\nBuilder.prototype.andWhereILike = Builder.prototype.whereILike;\nBuilder.prototype.andHaving = Builder.prototype.having;\nBuilder.prototype.andHavingIn = Builder.prototype.havingIn;\nBuilder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;\nBuilder.prototype.andHavingNull = Builder.prototype.havingNull;\nBuilder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;\nBuilder.prototype.andHavingExists = Builder.prototype.havingExists;\nBuilder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;\nBuilder.prototype.andHavingBetween = Builder.prototype.havingBetween;\nBuilder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;\nBuilder.prototype.from = Builder.prototype.table;\nBuilder.prototype.into = Builder.prototype.table;\nBuilder.prototype.del = Builder.prototype.delete;\n\n// Attach all of the top level promise methods that should be chainable.\naugmentWithBuilderInterface(Builder);\naddQueryContext(Builder);\nBuilder.extend = (methodName, fn) => {\n  if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {\n    throw new Error(`Can't extend QueryBuilder with existing method ('${methodName}').`);\n  }\n  assign(Builder.prototype, {\n    [methodName]: fn\n  });\n};\n\n// Sub-builder for onConflict clauses\nclass OnConflictBuilder {\n  constructor(builder, columns) {\n    this.builder = builder;\n    this._columns = columns;\n  }\n\n  // Sets insert query to ignore conflicts\n  ignore() {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.ignore = true;\n    return this.builder;\n  }\n\n  // Sets insert query to update on conflict\n  merge(updates) {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.merge = {\n      updates\n    };\n    return this.builder;\n  }\n\n  // Prevent\n  then() {\n    throw new Error('Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()');\n  }\n}\nmodule.exports = Builder;","map":{"version":3,"names":["assert","require","EventEmitter","assign","clone","each","isEmpty","isPlainObject","last","reject","tail","toArray","addQueryContext","normalizeArr","JoinClause","Analytic","saveAsyncStack","isBoolean","isNumber","isObject","isString","isFunction","lockMode","waitMode","augmentWithBuilderInterface","SELECT_COMMANDS","Set","CLEARABLE_STATEMENTS","LOCK_MODES","forShare","forUpdate","forNoKeyUpdate","forKeyShare","Builder","constructor","client","and","_single","_comments","_statements","_method","config","_debug","debug","_joinFlag","_boolFlag","_notFlag","_asColumnFlag","toString","toQuery","toSQL","method","tz","queryCompiler","cloned","_options","undefined","_queryContext","_connection","timeout","ms","cancel","arguments","length","_timeout","assertCanCancelQuery","_cancelOnTimeout","isValidStatementArg","statement","isRawInstance","_validateWithArgs","alias","statementOrColumnList","nothingOrStatement","query","columnList","Error","isNonEmptyNameList","Array","isArray","every","it","with","withWrapped","withMaterialized","withNotMaterialized","materialized","grouping","type","value","push","withRecursive","withRecursiveWrapped","recursive","columns","column","comment","txt","forbiddenChars","some","chars","includes","join","as","hintComment","hints","hint","withSchema","schemaName","schema","table","tableName","options","only","distinct","distinctOn","_len","args","_key","first","joinType","_joinType","call","raw","_len2","_key2","on","using","tables","innerJoin","leftJoin","leftOuterJoin","rightJoin","rightOuterJoin","outerJoin","fullOuterJoin","crossJoin","joinRaw","or","_bool","not","_not","where","operator","argsLength","whereWrapped","_objectWhere","whereRaw","whereNull","checkOperator","toLowerCase","trim","whereIn","whereBetween","bool","asColumn","whereColumn","orWhere","obj","key","andWhere","_len3","_key3","orWhereColumn","andWhereColumn","_len4","_key4","whereNot","_len5","_key5","logger","warn","whereNotColumn","orWhereNot","orWhereNotColumn","boolVal","notVal","sql","bindings","orWhereRaw","callback","whereExists","orWhereExists","whereNotExists","orWhereNotExists","values","orWhereIn","whereNotIn","orWhereNotIn","orWhereNull","whereNotNull","orWhereNotNull","whereNotBetween","orWhereBetween","orWhereNotBetween","_whereLike","whereLike","orWhereLike","whereILike","orWhereILike","groupBy","item","groupByRaw","apply","orderBy","direction","nulls","_orderByArray","columnDefs","i","columnInfo","orderByRaw","_union","clause","callbacks","wrap","l","slice","union","_len6","_key6","unionAll","_len7","_key7","intersect","_len8","_key8","except","_len9","_key9","having","havingRaw","havingWrapped","orHaving","andHaving","_len10","_key10","havingNull","orHavingNull","havingNotNull","orHavingNotNull","havingExists","orHavingExists","havingNotExists","orHavingNotExists","havingBetween","orHavingBetween","havingNotBetween","orHavingNotBetween","havingIn","orHavingIn","havingNotIn","orHavingNotIn","orHavingRaw","_setSkipBinding","attribute","skipBinding","offset","val","parseInt","isNaN","limit","count","_aggregate","min","max","sum","avg","countDistinct","_len11","_key11","splice","sumDistinct","avgDistinct","increment","amount","_counter","decrement","clearCounters","counter","select","connection","processPassedConnection","pluck","clearSelect","_clearGrouping","clearWhere","clearGroup","clearOrder","clearHaving","clear","has","startsWith","insert","returning","update","ret","JSON","stringify","keys","Object","onConflict","OnConflictBuilder","delete","truncate","lock","_len12","_key12","lockTables","_len13","_key13","_len14","_key14","_len15","_key15","skipLocked","_isSelectQuery","_hasLockMode","noWait","fromJS","fromRaw","from","modify","concat","upsert","dialect","_json","nameFunction","params","jsonExtract","path","singleValue","jsonSet","jsonInsert","jsonRemove","_isJsonObject","jsonValue","_whereJsonWrappedValue","whereJsonClause","jsonPath","whereJsonObject","orWhereJsonObject","whereNotJsonObject","orWhereNotJsonObject","whereJsonPath","orWhereJsonPath","whereJsonSupersetOf","whereJsonNotSupersetOf","orWhereJsonSupersetOf","orWhereJsonNotSupersetOf","whereJsonSubsetOf","whereJsonNotSubsetOf","orWhereJsonSubsetOf","orWhereJsonNotSubsetOf","whereJsonHasNone","whereJsonHasAll","_analytic","second","third","analytic","_analyticMethod","order","partitions","rank","denseRank","rowNumber","parseFloat","_analyticFlag","aggregateDistinct","prototype","andWhereNot","andWhereNotColumn","andWhereRaw","andWhereBetween","andWhereNotBetween","andWhereJsonObject","andWhereNotJsonObject","andWhereJsonPath","andWhereLike","andWhereILike","andHavingIn","andHavingNotIn","andHavingNull","andHavingNotNull","andHavingExists","andHavingNotExists","andHavingBetween","andHavingNotBetween","into","del","extend","methodName","fn","hasOwnProperty","builder","_columns","ignore","merge","updates","then","module","exports"],"sources":["/Users/george/Desktop/Backup_Developers_Institute/Final_Project_JS/Final_Project_JS/CookMate/cook_mate/node_modules/knex/lib/query/querybuilder.js"],"sourcesContent":["// Builder\n// -------\nconst assert = require('assert');\nconst { EventEmitter } = require('events');\nconst assign = require('lodash/assign');\nconst clone = require('lodash/clone');\nconst each = require('lodash/each');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst last = require('lodash/last');\nconst reject = require('lodash/reject');\nconst tail = require('lodash/tail');\nconst toArray = require('lodash/toArray');\n\nconst { addQueryContext, normalizeArr } = require('../util/helpers');\nconst JoinClause = require('./joinclause');\nconst Analytic = require('./analytic');\nconst saveAsyncStack = require('../util/save-async-stack');\nconst {\n  isBoolean,\n  isNumber,\n  isObject,\n  isString,\n  isFunction,\n} = require('../util/is');\n\nconst { lockMode, waitMode } = require('./constants');\nconst {\n  augmentWithBuilderInterface,\n} = require('../builder-interface-augmenter');\n\nconst SELECT_COMMANDS = new Set(['pluck', 'first', 'select']);\nconst CLEARABLE_STATEMENTS = new Set([\n  'with',\n  'select',\n  'columns',\n  'hintComments',\n  'where',\n  'union',\n  'join',\n  'group',\n  'order',\n  'having',\n  'limit',\n  'offset',\n  'counter',\n  'counters',\n]);\nconst LOCK_MODES = new Set([\n  lockMode.forShare,\n  lockMode.forUpdate,\n  lockMode.forNoKeyUpdate,\n  lockMode.forKeyShare,\n]);\n\n// Typically called from `knex.builder`,\n// start a new query building chain.\nclass Builder extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.and = this;\n    this._single = {};\n    this._comments = [];\n    this._statements = [];\n    this._method = 'select';\n    if (client.config) {\n      saveAsyncStack(this, 5);\n      this._debug = client.config.debug;\n    }\n    // Internal flags used in the builder.\n    this._joinFlag = 'inner';\n    this._boolFlag = 'and';\n    this._notFlag = false;\n    this._asColumnFlag = false;\n  }\n\n  toString() {\n    return this.toQuery();\n  }\n\n  // Convert the current query \"toSQL\"\n  toSQL(method, tz) {\n    return this.client.queryCompiler(this).toSQL(method || this._method, tz);\n  }\n\n  // Create a shallow clone of the current query builder.\n  clone() {\n    const cloned = new this.constructor(this.client);\n    cloned._method = this._method;\n    cloned._single = clone(this._single);\n    cloned._comments = clone(this._comments);\n    cloned._statements = clone(this._statements);\n    cloned._debug = this._debug;\n\n    // `_option` is assigned by the `Interface` mixin.\n    if (this._options !== undefined) {\n      cloned._options = clone(this._options);\n    }\n    if (this._queryContext !== undefined) {\n      cloned._queryContext = clone(this._queryContext);\n    }\n    if (this._connection !== undefined) {\n      cloned._connection = this._connection;\n    }\n\n    return cloned;\n  }\n\n  timeout(ms, { cancel } = {}) {\n    if (isNumber(ms) && ms > 0) {\n      this._timeout = ms;\n      if (cancel) {\n        this.client.assertCanCancelQuery();\n        this._cancelOnTimeout = true;\n      }\n    }\n    return this;\n  }\n\n  // With\n  // ------\n  isValidStatementArg(statement) {\n    return (\n      typeof statement === 'function' ||\n      statement instanceof Builder ||\n      (statement && statement.isRawInstance)\n    );\n  }\n\n  _validateWithArgs(alias, statementOrColumnList, nothingOrStatement, method) {\n    const [query, columnList] =\n      typeof nothingOrStatement === 'undefined'\n        ? [statementOrColumnList, undefined]\n        : [nothingOrStatement, statementOrColumnList];\n    if (typeof alias !== 'string') {\n      throw new Error(`${method}() first argument must be a string`);\n    }\n\n    if (this.isValidStatementArg(query) && typeof columnList === 'undefined') {\n      // Validated as two-arg variant (alias, statement).\n      return;\n    }\n\n    // Attempt to interpret as three-arg variant (alias, columnList, statement).\n    const isNonEmptyNameList =\n      Array.isArray(columnList) &&\n      columnList.length > 0 &&\n      columnList.every((it) => typeof it === 'string');\n    if (!isNonEmptyNameList) {\n      throw new Error(\n        `${method}() second argument must be a statement or non-empty column name list.`\n      );\n    }\n\n    if (this.isValidStatementArg(query)) {\n      return;\n    }\n    throw new Error(\n      `${method}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`\n    );\n  }\n\n  with(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(\n      alias,\n      statementOrColumnList,\n      nothingOrStatement,\n      'with'\n    );\n    return this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n  }\n\n  withMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n\n  withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n\n  // Helper for compiling any advanced `with` queries.\n  withWrapped(alias, statementOrColumnList, nothingOrStatement, materialized) {\n    const [query, columnList] =\n      typeof nothingOrStatement === 'undefined'\n        ? [statementOrColumnList, undefined]\n        : [nothingOrStatement, statementOrColumnList];\n    const statement = {\n      grouping: 'with',\n      type: 'withWrapped',\n      alias: alias,\n      columnList,\n      value: query,\n    };\n    if (materialized !== undefined) {\n      statement.materialized = materialized;\n    }\n    this._statements.push(statement);\n    return this;\n  }\n\n  // With Recursive\n  // ------\n\n  withRecursive(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(\n      alias,\n      statementOrColumnList,\n      nothingOrStatement,\n      'withRecursive'\n    );\n    return this.withRecursiveWrapped(\n      alias,\n      statementOrColumnList,\n      nothingOrStatement\n    );\n  }\n\n  // Helper for compiling any advanced `withRecursive` queries.\n  withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement) {\n    this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n    this._statements[this._statements.length - 1].recursive = true;\n    return this;\n  }\n\n  // Select\n  // ------\n\n  // Adds a column or columns to the list of \"columns\"\n  // being selected on the query.\n  columns(column) {\n    if (!column && column !== 0) return this;\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...arguments),\n    });\n    return this;\n  }\n\n  // Adds a comment to the query\n  comment(txt) {\n    if (!isString(txt)) {\n      throw new Error('Comment must be a string');\n    }\n    const forbiddenChars = ['/*', '*/', '?'];\n    if (forbiddenChars.some((chars) => txt.includes(chars))) {\n      throw new Error(`Cannot include ${forbiddenChars.join(', ')} in comment`);\n    }\n    this._comments.push({\n      comment: txt,\n    });\n    return this;\n  }\n\n  // Allow for a sub-select to be explicitly aliased as a column,\n  // without needing to compile the query in a where.\n  as(column) {\n    this._single.as = column;\n    return this;\n  }\n\n  // Adds a single hint or an array of hits to the list of \"hintComments\" on the query.\n  hintComment(hints) {\n    hints = Array.isArray(hints) ? hints : [hints];\n    if (hints.some((hint) => !isString(hint))) {\n      throw new Error('Hint comment must be a string');\n    }\n    if (hints.some((hint) => hint.includes('/*') || hint.includes('*/'))) {\n      throw new Error('Hint comment cannot include \"/*\" or \"*/\"');\n    }\n    if (hints.some((hint) => hint.includes('?'))) {\n      throw new Error('Hint comment cannot include \"?\"');\n    }\n    this._statements.push({\n      grouping: 'hintComments',\n      value: hints,\n    });\n    return this;\n  }\n\n  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.\n  withSchema(schemaName) {\n    this._single.schema = schemaName;\n    return this;\n  }\n\n  // Sets the `tableName` on the query.\n  // Alias to \"from\" for select and \"into\" for insert statements\n  // e.g. builder.insert({a: value}).into('tableName')\n  // `options`: options object containing keys:\n  //   - `only`: whether the query should use SQL's ONLY to not return\n  //           inheriting table data. Defaults to false.\n  table(tableName, options = {}) {\n    this._single.table = tableName;\n    this._single.only = options.only === true;\n    return this;\n  }\n\n  // Adds a `distinct` clause to the query.\n  distinct(...args) {\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinct: true,\n    });\n    return this;\n  }\n\n  distinctOn(...args) {\n    if (isEmpty(args)) {\n      throw new Error('distinctOn requires at least on argument');\n    }\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinctOn: true,\n    });\n    return this;\n  }\n\n  // Adds a join clause to the query, allowing for advanced joins\n  // with an anonymous function as the second argument.\n  join(table, first, ...args) {\n    let join;\n    const schema =\n      table instanceof Builder || typeof table === 'function'\n        ? undefined\n        : this._single.schema;\n    const joinType = this._joinType();\n    if (typeof first === 'function') {\n      join = new JoinClause(table, joinType, schema);\n      first.call(join, join);\n    } else if (joinType === 'raw') {\n      join = new JoinClause(this.client.raw(table, first), 'raw');\n    } else {\n      join = new JoinClause(table, joinType, schema);\n      if (first) {\n        join.on(first, ...args);\n      }\n    }\n    this._statements.push(join);\n    return this;\n  }\n\n  using(tables) {\n    throw new Error(\n      \"'using' function is only available in PostgreSQL dialect with Delete statements.\"\n    );\n  }\n\n  // JOIN blocks:\n  innerJoin(...args) {\n    return this._joinType('inner').join(...args);\n  }\n\n  leftJoin(...args) {\n    return this._joinType('left').join(...args);\n  }\n\n  leftOuterJoin(...args) {\n    return this._joinType('left outer').join(...args);\n  }\n\n  rightJoin(...args) {\n    return this._joinType('right').join(...args);\n  }\n\n  rightOuterJoin(...args) {\n    return this._joinType('right outer').join(...args);\n  }\n\n  outerJoin(...args) {\n    return this._joinType('outer').join(...args);\n  }\n\n  fullOuterJoin(...args) {\n    return this._joinType('full outer').join(...args);\n  }\n\n  crossJoin(...args) {\n    return this._joinType('cross').join(...args);\n  }\n\n  joinRaw(...args) {\n    return this._joinType('raw').join(...args);\n  }\n\n  // Where modifiers:\n  get or() {\n    return this._bool('or');\n  }\n\n  get not() {\n    return this._not(true);\n  }\n\n  // The where function can be used in several ways:\n  // The most basic is `where(key, value)`, which expands to\n  // where key = value.\n  where(column, operator, value) {\n    const argsLength = arguments.length;\n\n    // Support \"where true || where false\"\n    if (column === false || column === true) {\n      return this.where(1, '=', column ? 1 : 0);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a where statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.whereWrapped(column);\n    }\n\n    // Allows `where({id: 2})` syntax.\n    if (isObject(column) && !column.isRawInstance)\n      return this._objectWhere(column);\n\n    // Allow a raw statement to be passed along to the query.\n    if (column && column.isRawInstance && argsLength === 1)\n      return this.whereRaw(column);\n\n    // Enable the where('key', value) syntax, only when there\n    // are explicitly two arguments passed, so it's not possible to\n    // do where('key', '!=') and have that turn into where key != null\n    if (argsLength === 2) {\n      value = operator;\n      operator = '=';\n\n      // If the value is null, and it's a two argument query,\n      // we assume we're going for a `whereNull`.\n      if (value === null) {\n        return this.whereNull(column);\n      }\n    }\n\n    // lower case the operator for comparison purposes\n    const checkOperator = `${operator}`.toLowerCase().trim();\n\n    // If there are 3 arguments, check whether 'in' is one of them.\n    if (argsLength === 3) {\n      if (checkOperator === 'in' || checkOperator === 'not in') {\n        return this._not(checkOperator === 'not in').whereIn(column, value);\n      }\n      if (checkOperator === 'between' || checkOperator === 'not between') {\n        return this._not(checkOperator === 'not between').whereBetween(\n          column,\n          value\n        );\n      }\n    }\n\n    // If the value is still null, check whether they're meaning\n    // where value is null\n    if (value === null) {\n      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');\n      if (checkOperator === 'is' || checkOperator === 'is not') {\n        return this._not(checkOperator === 'is not').whereNull(column);\n      }\n    }\n\n    // Push onto the where statement stack.\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBasic',\n      column,\n      operator,\n      value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag,\n    });\n    return this;\n  }\n\n  whereColumn(...args) {\n    this._asColumnFlag = true;\n    this.where(...args);\n    this._asColumnFlag = false;\n    return this;\n  }\n\n  // Adds an `or where` clause to the query.\n  orWhere(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhere(key, obj[key]);\n        }\n      });\n    }\n    return this.where(column, ...args);\n  }\n\n  orWhereColumn(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhereColumn(key, '=', obj[key]);\n        }\n      });\n    }\n    return this.whereColumn(column, ...args);\n  }\n\n  // Adds an `not where` clause to the query.\n  whereNot(column, ...args) {\n    if (args.length >= 2) {\n      if (args[0] === 'in' || args[0] === 'between') {\n        this.client.logger.warn(\n          'whereNot is not suitable for \"in\" and \"between\" type subqueries. You should use \"not in\" and \"not between\" instead.'\n        );\n      }\n    }\n    return this._not(true).where(column, ...args);\n  }\n\n  whereNotColumn(...args) {\n    return this._not(true).whereColumn(...args);\n  }\n\n  // Adds an `or not where` clause to the query.\n  orWhereNot(...args) {\n    return this._bool('or').whereNot(...args);\n  }\n\n  orWhereNotColumn(...args) {\n    return this._bool('or').whereNotColumn(...args);\n  }\n\n  // Processes an object literal provided in a \"where\" clause.\n  _objectWhere(obj) {\n    const boolVal = this._bool();\n    const notVal = this._not() ? 'Not' : '';\n    for (const key in obj) {\n      this[boolVal + 'Where' + notVal](key, obj[key]);\n    }\n    return this;\n  }\n\n  // Adds a raw `where` clause to the query.\n  whereRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereRaw',\n      value: raw,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orWhereRaw(sql, bindings) {\n    return this._bool('or').whereRaw(sql, bindings);\n  }\n\n  // Helper for compiling any advanced `where` queries.\n  whereWrapped(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereWrapped',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `where exists` clause to the query.\n  whereExists(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds an `or where exists` clause to the query.\n  orWhereExists(callback) {\n    return this._bool('or').whereExists(callback);\n  }\n\n  // Adds a `where not exists` clause to the query.\n  whereNotExists(callback) {\n    return this._not(true).whereExists(callback);\n  }\n\n  // Adds a `or where not exists` clause to the query.\n  orWhereNotExists(callback) {\n    return this._bool('or').whereNotExists(callback);\n  }\n\n  // Adds a `where in` clause to the query.\n  whereIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values))\n      return this.where(this._not());\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orWhereIn(column, values) {\n    return this._bool('or').whereIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  whereNotIn(column, values) {\n    return this._not(true).whereIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orWhereNotIn(column, values) {\n    return this._bool('or')._not(true).whereIn(column, values);\n  }\n\n  // Adds a `where null` clause to the query.\n  whereNull(column) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereNull',\n      column,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where null` clause to the query.\n  orWhereNull(column) {\n    return this._bool('or').whereNull(column);\n  }\n\n  // Adds a `where not null` clause to the query.\n  whereNotNull(column) {\n    return this._not(true).whereNull(column);\n  }\n\n  // Adds a `or where not null` clause to the query.\n  orWhereNotNull(column) {\n    return this._bool('or').whereNotNull(column);\n  }\n\n  // Adds a `where between` clause to the query.\n  whereBetween(column, values) {\n    assert(\n      Array.isArray(values),\n      'The second argument to whereBetween must be an array.'\n    );\n    assert(\n      values.length === 2,\n      'You must specify 2 values for the whereBetween clause'\n    );\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `where not between` clause to the query.\n  whereNotBetween(column, values) {\n    return this._not(true).whereBetween(column, values);\n  }\n\n  // Adds a `or where between` clause to the query.\n  orWhereBetween(column, values) {\n    return this._bool('or').whereBetween(column, values);\n  }\n\n  // Adds a `or where not between` clause to the query.\n  orWhereNotBetween(column, values) {\n    return this._bool('or').whereNotBetween(column, values);\n  }\n\n  _whereLike(type, column, value) {\n    this._statements.push({\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag,\n    });\n    return this;\n  }\n\n  // Adds a `where like` clause to the query.\n  whereLike(column, value) {\n    return this._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `or where like` clause to the query.\n  orWhereLike(column, value) {\n    return this._bool('or')._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `where ilike` clause to the query.\n  whereILike(column, value) {\n    return this._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `or where ilike` clause to the query.\n  orWhereILike(column, value) {\n    return this._bool('or')._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `group by` clause to the query.\n  groupBy(item) {\n    if (item && item.isRawInstance) {\n      return this.groupByRaw.apply(this, arguments);\n    }\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByBasic',\n      value: normalizeArr(...arguments),\n    });\n    return this;\n  }\n\n  // Adds a raw `group by` clause to the query.\n  groupByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByRaw',\n      value: raw,\n    });\n    return this;\n  }\n\n  // Adds a `order by` clause to the query.\n  orderBy(column, direction, nulls = '') {\n    if (Array.isArray(column)) {\n      return this._orderByArray(column);\n    }\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByBasic',\n      value: column,\n      direction,\n      nulls,\n    });\n    return this;\n  }\n\n  // Adds a `order by` with multiple columns to the query.\n  _orderByArray(columnDefs) {\n    for (let i = 0; i < columnDefs.length; i++) {\n      const columnInfo = columnDefs[i];\n      if (isObject(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo['column'],\n          direction: columnInfo['order'],\n          nulls: columnInfo['nulls'],\n        });\n      } else if (isString(columnInfo) || isNumber(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo,\n        });\n      }\n    }\n    return this;\n  }\n\n  // Add a raw `order by` clause to the query.\n  orderByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByRaw',\n      value: raw,\n    });\n    return this;\n  }\n\n  _union(clause, args) {\n    let callbacks = args[0];\n    let wrap = args[1];\n    if (args.length === 1 || (args.length === 2 && isBoolean(wrap))) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: clause,\n          value: callbacks[i],\n          wrap: wrap || false,\n        });\n      }\n    } else {\n      callbacks = toArray(args).slice(0, args.length - 1);\n      wrap = args[args.length - 1];\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n      this._union(clause, [callbacks, wrap]);\n    }\n    return this;\n  }\n\n  // Add a union statement to the query.\n  union(...args) {\n    return this._union('union', args);\n  }\n\n  // Adds a union all statement to the query.\n  unionAll(...args) {\n    return this._union('union all', args);\n  }\n\n  intersect(...args) {\n    return this._union('intersect', args);\n  }\n\n  except(...args) {\n    return this._union('except', args);\n  }\n\n  // Adds a `having` clause to the query.\n  having(column, operator, value) {\n    if (column.isRawInstance && arguments.length === 1) {\n      return this.havingRaw(column);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a having statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.havingWrapped(column);\n    }\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBasic',\n      column,\n      operator,\n      value,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  orHaving(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.havingWrapped(function () {\n        for (const key in obj) {\n          this.andHaving(key, obj[key]);\n        }\n      });\n    }\n    return this.having(column, ...args);\n  }\n\n  // Helper for compiling any advanced `having` queries.\n  havingWrapped(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingWrapped',\n      value: callback,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  havingNull(column) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingNull',\n      column,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingNull(callback) {\n    return this._bool('or').havingNull(callback);\n  }\n\n  havingNotNull(callback) {\n    return this._not(true).havingNull(callback);\n  }\n\n  orHavingNotNull(callback) {\n    return this._not(true)._bool('or').havingNull(callback);\n  }\n\n  havingExists(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingExists(callback) {\n    return this._bool('or').havingExists(callback);\n  }\n\n  havingNotExists(callback) {\n    return this._not(true).havingExists(callback);\n  }\n\n  orHavingNotExists(callback) {\n    return this._not(true)._bool('or').havingExists(callback);\n  }\n\n  havingBetween(column, values) {\n    assert(\n      Array.isArray(values),\n      'The second argument to havingBetween must be an array.'\n    );\n    assert(\n      values.length === 2,\n      'You must specify 2 values for the havingBetween clause'\n    );\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingBetween(column, values) {\n    return this._bool('or').havingBetween(column, values);\n  }\n\n  havingNotBetween(column, values) {\n    return this._not(true).havingBetween(column, values);\n  }\n\n  orHavingNotBetween(column, values) {\n    return this._not(true)._bool('or').havingBetween(column, values);\n  }\n\n  havingIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values))\n      return this.where(this._not());\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orHavingIn(column, values) {\n    return this._bool('or').havingIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  havingNotIn(column, values) {\n    return this._not(true).havingIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orHavingNotIn(column, values) {\n    return this._bool('or')._not(true).havingIn(column, values);\n  }\n\n  // Adds a raw `having` clause to the query.\n  havingRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingRaw',\n      value: raw,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  orHavingRaw(sql, bindings) {\n    return this._bool('or').havingRaw(sql, bindings);\n  }\n\n  // set the skip binding parameter (= insert the raw value in the query) for an attribute.\n  _setSkipBinding(attribute, options) {\n    let skipBinding = options;\n    if (isObject(options)) {\n      skipBinding = options.skipBinding;\n    }\n    this._single.skipBinding = this._single.skipBinding || {};\n    this._single.skipBinding[attribute] = skipBinding;\n  }\n\n  // Only allow a single \"offset\" to be set for the current query.\n  offset(value, options) {\n    if (value == null || value.isRawInstance || value instanceof Builder) {\n      // Builder for backward compatibility\n      this._single.offset = value;\n    } else {\n      const val = parseInt(value, 10);\n      if (isNaN(val)) {\n        this.client.logger.warn('A valid integer must be provided to offset');\n      } else if (val < 0) {\n        throw new Error(`A non-negative integer must be provided to offset.`);\n      } else {\n        this._single.offset = val;\n      }\n    }\n    this._setSkipBinding('offset', options);\n    return this;\n  }\n\n  // Only allow a single \"limit\" to be set for the current query.\n  limit(value, options) {\n    const val = parseInt(value, 10);\n    if (isNaN(val)) {\n      this.client.logger.warn('A valid integer must be provided to limit');\n    } else {\n      this._single.limit = val;\n      this._setSkipBinding('limit', options);\n    }\n    return this;\n  }\n\n  // Retrieve the \"count\" result of the query.\n  count(column, options) {\n    return this._aggregate('count', column || '*', options);\n  }\n\n  // Retrieve the minimum value of a given column.\n  min(column, options) {\n    return this._aggregate('min', column, options);\n  }\n\n  // Retrieve the maximum value of a given column.\n  max(column, options) {\n    return this._aggregate('max', column, options);\n  }\n\n  // Retrieve the sum of the values of a given column.\n  sum(column, options) {\n    return this._aggregate('sum', column, options);\n  }\n\n  // Retrieve the average of the values of a given column.\n  avg(column, options) {\n    return this._aggregate('avg', column, options);\n  }\n\n  // Retrieve the \"count\" of the distinct results of the query.\n  countDistinct(...columns) {\n    let options;\n    if (columns.length > 1 && isPlainObject(last(columns))) {\n      [options] = columns.splice(columns.length - 1, 1);\n    }\n\n    if (!columns.length) {\n      columns = '*';\n    } else if (columns.length === 1) {\n      columns = columns[0];\n    }\n\n    return this._aggregate('count', columns, { ...options, distinct: true });\n  }\n\n  // Retrieve the sum of the distinct values of a given column.\n  sumDistinct(column, options) {\n    return this._aggregate('sum', column, { ...options, distinct: true });\n  }\n\n  // Retrieve the vg of the distinct results of the query.\n  avgDistinct(column, options) {\n    return this._aggregate('avg', column, { ...options, distinct: true });\n  }\n\n  // Increments a column's value by the specified amount.\n  increment(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, amount);\n  }\n\n  // Decrements a column's value by the specified amount.\n  decrement(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, -column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, -amount);\n  }\n\n  // Clears increments/decrements\n  clearCounters() {\n    this._single.counter = {};\n    return this;\n  }\n\n  // Sets the values for a `select` query, informing that only the first\n  // row should be returned (limit 1).\n  first(...args) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .first() on \"${this._method}\" query`);\n    }\n\n    this.select(normalizeArr(...args));\n    this._method = 'first';\n    this.limit(1);\n    return this;\n  }\n\n  // Use existing connection to execute the query\n  // Same value that client.acquireConnection() for an according client returns should be passed\n  connection(_connection) {\n    this._connection = _connection;\n    this.client.processPassedConnection(_connection);\n    return this;\n  }\n\n  // Pluck a column from a query.\n  pluck(column) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .pluck() on \"${this._method}\" query`);\n    }\n\n    this._method = 'pluck';\n    this._single.pluck = column;\n    this._statements.push({\n      grouping: 'columns',\n      type: 'pluck',\n      value: column,\n    });\n    return this;\n  }\n\n  // Deprecated. Remove everything from select clause\n  clearSelect() {\n    this._clearGrouping('columns');\n    return this;\n  }\n\n  // Deprecated. Remove everything from where clause\n  clearWhere() {\n    this._clearGrouping('where');\n    return this;\n  }\n\n  // Deprecated. Remove everything from group clause\n  clearGroup() {\n    this._clearGrouping('group');\n    return this;\n  }\n\n  // Deprecated. Remove everything from order clause\n  clearOrder() {\n    this._clearGrouping('order');\n    return this;\n  }\n\n  // Deprecated. Remove everything from having clause\n  clearHaving() {\n    this._clearGrouping('having');\n    return this;\n  }\n\n  // Remove everything from statement clause\n  clear(statement) {\n    if (!CLEARABLE_STATEMENTS.has(statement))\n      throw new Error(`Knex Error: unknown statement '${statement}'`);\n    if (statement.startsWith('counter')) return this.clearCounters();\n    if (statement === 'select') {\n      statement = 'columns';\n    }\n    this._clearGrouping(statement);\n    return this;\n  }\n\n  // Insert & Update\n  // ------\n\n  // Sets the values for an `insert` query.\n  insert(values, returning, options) {\n    this._method = 'insert';\n    if (!isEmpty(returning)) this.returning(returning, options);\n    this._single.insert = values;\n    return this;\n  }\n\n  // Sets the values for an `update`, allowing for both\n  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.\n  update(values, returning, options) {\n    let ret;\n    const obj = this._single.update || {};\n    this._method = 'update';\n    if (isString(values)) {\n      if (isPlainObject(returning)) {\n        obj[values] = JSON.stringify(returning);\n      } else {\n        obj[values] = returning;\n      }\n      if (arguments.length > 2) {\n        ret = arguments[2];\n      }\n    } else {\n      const keys = Object.keys(values);\n      if (this._single.update) {\n        this.client.logger.warn('Update called multiple times with objects.');\n      }\n      let i = -1;\n      while (++i < keys.length) {\n        obj[keys[i]] = values[keys[i]];\n      }\n      ret = arguments[1];\n    }\n    if (!isEmpty(ret)) this.returning(ret, options);\n    this._single.update = obj;\n    return this;\n  }\n\n  // Sets the returning value for the query.\n  returning(returning, options) {\n    this._single.returning = returning;\n    this._single.options = options;\n    return this;\n  }\n\n  onConflict(columns) {\n    if (typeof columns === 'string') {\n      columns = [columns];\n    }\n    return new OnConflictBuilder(this, columns || true);\n  }\n\n  // Delete\n  // ------\n\n  // Executes a delete statement on the query;\n  delete(ret, options) {\n    this._method = 'del';\n    if (!isEmpty(ret)) this.returning(ret, options);\n    return this;\n  }\n\n  // Truncates a table, ends the query chain.\n  truncate(tableName) {\n    this._method = 'truncate';\n    if (tableName) {\n      this._single.table = tableName;\n    }\n    return this;\n  }\n\n  // Retrieves columns for the table specified by `knex(tableName)`\n  columnInfo(column) {\n    this._method = 'columnInfo';\n    this._single.columnInfo = column;\n    return this;\n  }\n\n  // Set a lock for update constraint.\n  forUpdate(...tables) {\n    this._single.lock = lockMode.forUpdate;\n    if (tables.length === 1 && Array.isArray(tables[0])) {\n      this._single.lockTables = tables[0];\n    } else {\n      this._single.lockTables = tables;\n    }\n    return this;\n  }\n\n  // Set a lock for share constraint.\n  forShare(...tables) {\n    this._single.lock = lockMode.forShare;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for no key update constraint.\n  forNoKeyUpdate(...tables) {\n    this._single.lock = lockMode.forNoKeyUpdate;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for key share constraint.\n  forKeyShare(...tables) {\n    this._single.lock = lockMode.forKeyShare;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Skips locked rows when using a lock constraint.\n  skipLocked() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .skipLocked() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error(\n        '.skipLocked() can only be used after a call to .forShare() or .forUpdate()!'\n      );\n    }\n    if (this._single.waitMode === waitMode.noWait) {\n      throw new Error('.skipLocked() cannot be used together with .noWait()!');\n    }\n    this._single.waitMode = waitMode.skipLocked;\n    return this;\n  }\n\n  // Causes error when acessing a locked row instead of waiting for it to be released.\n  noWait() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .noWait() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error(\n        '.noWait() can only be used after a call to .forShare() or .forUpdate()!'\n      );\n    }\n    if (this._single.waitMode === waitMode.skipLocked) {\n      throw new Error('.noWait() cannot be used together with .skipLocked()!');\n    }\n    this._single.waitMode = waitMode.noWait;\n    return this;\n  }\n\n  // Takes a JS object of methods to call and calls them\n  fromJS(obj) {\n    each(obj, (val, key) => {\n      if (typeof this[key] !== 'function') {\n        this.client.logger.warn(`Knex Error: unknown key ${key}`);\n      }\n      if (Array.isArray(val)) {\n        this[key].apply(this, val);\n      } else {\n        this[key](val);\n      }\n    });\n    return this;\n  }\n\n  fromRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    return this.from(raw);\n  }\n\n  // Passes query to provided callback function, useful for e.g. composing\n  // domain-specific helpers\n  modify(callback) {\n    callback.apply(this, [this].concat(tail(arguments)));\n    return this;\n  }\n\n  upsert(values, returning, options) {\n    throw new Error(\n      `Upsert is not yet supported for dialect ${this.client.dialect}`\n    );\n  }\n\n  // JSON support functions\n  _json(nameFunction, params) {\n    this._statements.push({\n      grouping: 'columns',\n      type: 'json',\n      method: nameFunction,\n      params: params,\n    });\n    return this;\n  }\n\n  jsonExtract() {\n    const column = arguments[0];\n    let path;\n    let alias;\n    let singleValue = true;\n\n    // We use arguments to have the signatures :\n    // - column (string or array)\n    // - column + path\n    // - column + path + alias\n    // - column + path + alias + singleValue\n    // - column array + singleValue\n    if (arguments.length >= 2) {\n      path = arguments[1];\n    }\n    if (arguments.length >= 3) {\n      alias = arguments[2];\n    }\n    if (arguments.length === 4) {\n      singleValue = arguments[3];\n    }\n    if (\n      arguments.length === 2 &&\n      Array.isArray(arguments[0]) &&\n      isBoolean(arguments[1])\n    ) {\n      singleValue = arguments[1];\n    }\n    return this._json('jsonExtract', {\n      column: column,\n      path: path,\n      alias: alias,\n      singleValue, // boolean used only in MSSQL to use function for extract value instead of object/array.\n    });\n  }\n\n  jsonSet(column, path, value, alias) {\n    return this._json('jsonSet', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias,\n    });\n  }\n\n  jsonInsert(column, path, value, alias) {\n    return this._json('jsonInsert', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias,\n    });\n  }\n\n  jsonRemove(column, path, alias) {\n    return this._json('jsonRemove', {\n      column: column,\n      path: path,\n      alias: alias,\n    });\n  }\n\n  // Wheres for JSON\n  _isJsonObject(jsonValue) {\n    return isObject(jsonValue) && !(jsonValue instanceof Builder);\n  }\n\n  _whereJsonWrappedValue(type, column, value) {\n    const whereJsonClause = {\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag,\n    };\n    if (arguments[3]) {\n      whereJsonClause.operator = arguments[3];\n    }\n    if (arguments[4]) {\n      whereJsonClause.jsonPath = arguments[4];\n    }\n    this._statements.push(whereJsonClause);\n  }\n\n  whereJsonObject(column, value) {\n    this._whereJsonWrappedValue('whereJsonObject', column, value);\n    return this;\n  }\n\n  orWhereJsonObject(column, value) {\n    return this._bool('or').whereJsonObject(column, value);\n  }\n\n  whereNotJsonObject(column, value) {\n    return this._not(true).whereJsonObject(column, value);\n  }\n\n  orWhereNotJsonObject(column, value) {\n    return this._bool('or').whereNotJsonObject(column, value);\n  }\n\n  whereJsonPath(column, path, operator, value) {\n    this._whereJsonWrappedValue('whereJsonPath', column, value, operator, path);\n    return this;\n  }\n\n  orWhereJsonPath(column, path, operator, value) {\n    return this._bool('or').whereJsonPath(column, path, operator, value);\n  }\n\n  // Json superset wheres\n  whereJsonSupersetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSupersetOf', column, value);\n    return this;\n  }\n\n  whereJsonNotSupersetOf(column, value) {\n    return this._not(true).whereJsonSupersetOf(column, value);\n  }\n\n  orWhereJsonSupersetOf(column, value) {\n    return this._bool('or').whereJsonSupersetOf(column, value);\n  }\n\n  orWhereJsonNotSupersetOf(column, value) {\n    return this._bool('or').whereJsonNotSupersetOf(column, value);\n  }\n\n  // Json subset wheres\n  whereJsonSubsetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSubsetOf', column, value);\n    return this;\n  }\n\n  whereJsonNotSubsetOf(column, value) {\n    return this._not(true).whereJsonSubsetOf(column, value);\n  }\n\n  orWhereJsonSubsetOf(column, value) {\n    return this._bool('or').whereJsonSubsetOf(column, value);\n  }\n\n  orWhereJsonNotSubsetOf(column, value) {\n    return this._bool('or').whereJsonNotSubsetOf(column, value);\n  }\n\n  whereJsonHasNone(column, values) {\n    this._not(true).whereJsonHasAll(column, values);\n    return this;\n  }\n\n  // end of wheres for JSON\n\n  _analytic(alias, second, third) {\n    let analytic;\n    const { schema } = this._single;\n    const method = this._analyticMethod();\n    alias = typeof alias === 'string' ? alias : null;\n\n    assert(\n      typeof second === 'function' ||\n        second.isRawInstance ||\n        Array.isArray(second) ||\n        typeof second === 'string' ||\n        typeof second === 'object',\n      `The second argument to an analytic function must be either a function, a raw,\n       an array of string or object, an object or a single string.`\n    );\n\n    if (third) {\n      assert(\n        Array.isArray(third) ||\n          typeof third === 'string' ||\n          typeof third === 'object',\n        'The third argument to an analytic function must be either a string, an array of string or object or an object.'\n      );\n    }\n\n    if (isFunction(second)) {\n      analytic = new Analytic(method, schema, alias);\n      second.call(analytic, analytic);\n    } else if (second.isRawInstance) {\n      const raw = second;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        raw: raw,\n        alias: alias,\n      };\n    } else {\n      const order = !Array.isArray(second) ? [second] : second;\n      let partitions = third || [];\n      partitions = !Array.isArray(partitions) ? [partitions] : partitions;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        order: order,\n        alias: alias,\n        partitions: partitions,\n      };\n    }\n    this._statements.push(analytic);\n    return this;\n  }\n\n  rank(...args) {\n    return this._analyticMethod('rank')._analytic(...args);\n  }\n\n  denseRank(...args) {\n    return this._analyticMethod('dense_rank')._analytic(...args);\n  }\n\n  rowNumber(...args) {\n    return this._analyticMethod('row_number')._analytic(...args);\n  }\n\n  // ----------------------------------------------------------------------\n\n  // Helper for the incrementing/decrementing queries.\n  _counter(column, amount) {\n    amount = parseFloat(amount);\n\n    this._method = 'update';\n\n    this._single.counter = this._single.counter || {};\n\n    this._single.counter[column] = amount;\n\n    return this;\n  }\n\n  // Helper to get or set the \"boolFlag\" value.\n  _bool(val) {\n    if (arguments.length === 1) {\n      this._boolFlag = val;\n      return this;\n    }\n    const ret = this._boolFlag;\n    this._boolFlag = 'and';\n    return ret;\n  }\n\n  // Helper to get or set the \"notFlag\" value.\n  _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n    const ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  }\n\n  // Helper to get or set the \"joinFlag\" value.\n  _joinType(val) {\n    if (arguments.length === 1) {\n      this._joinFlag = val;\n      return this;\n    }\n    const ret = this._joinFlag || 'inner';\n    this._joinFlag = 'inner';\n    return ret;\n  }\n\n  _analyticMethod(val) {\n    if (arguments.length === 1) {\n      this._analyticFlag = val;\n      return this;\n    }\n    return this._analyticFlag || 'row_number';\n  }\n\n  // Helper for compiling any aggregate queries.\n  _aggregate(method, column, options = {}) {\n    this._statements.push({\n      grouping: 'columns',\n      type: column.isRawInstance ? 'aggregateRaw' : 'aggregate',\n      method,\n      value: column,\n      aggregateDistinct: options.distinct || false,\n      alias: options.as,\n    });\n    return this;\n  }\n\n  // Helper function for clearing or reseting a grouping type from the builder\n  _clearGrouping(grouping) {\n    if (grouping in this._single) {\n      this._single[grouping] = undefined;\n    } else {\n      this._statements = reject(this._statements, { grouping });\n    }\n  }\n\n  // Helper function that checks if the builder will emit a select query\n  _isSelectQuery() {\n    return SELECT_COMMANDS.has(this._method);\n  }\n\n  // Helper function that checks if the query has a lock mode set\n  _hasLockMode() {\n    return LOCK_MODES.has(this._single.lock);\n  }\n}\n\nBuilder.prototype.select = Builder.prototype.columns;\nBuilder.prototype.column = Builder.prototype.columns;\nBuilder.prototype.andWhereNot = Builder.prototype.whereNot;\nBuilder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;\nBuilder.prototype.andWhere = Builder.prototype.where;\nBuilder.prototype.andWhereColumn = Builder.prototype.whereColumn;\nBuilder.prototype.andWhereRaw = Builder.prototype.whereRaw;\nBuilder.prototype.andWhereBetween = Builder.prototype.whereBetween;\nBuilder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;\nBuilder.prototype.andWhereJsonObject = Builder.prototype.whereJsonObject;\nBuilder.prototype.andWhereNotJsonObject = Builder.prototype.whereJsonObject;\nBuilder.prototype.andWhereJsonPath = Builder.prototype.whereJsonPath;\nBuilder.prototype.andWhereLike = Builder.prototype.whereLike;\nBuilder.prototype.andWhereILike = Builder.prototype.whereILike;\nBuilder.prototype.andHaving = Builder.prototype.having;\nBuilder.prototype.andHavingIn = Builder.prototype.havingIn;\nBuilder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;\nBuilder.prototype.andHavingNull = Builder.prototype.havingNull;\nBuilder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;\nBuilder.prototype.andHavingExists = Builder.prototype.havingExists;\nBuilder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;\nBuilder.prototype.andHavingBetween = Builder.prototype.havingBetween;\nBuilder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;\nBuilder.prototype.from = Builder.prototype.table;\nBuilder.prototype.into = Builder.prototype.table;\nBuilder.prototype.del = Builder.prototype.delete;\n\n// Attach all of the top level promise methods that should be chainable.\naugmentWithBuilderInterface(Builder);\naddQueryContext(Builder);\n\nBuilder.extend = (methodName, fn) => {\n  if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {\n    throw new Error(\n      `Can't extend QueryBuilder with existing method ('${methodName}').`\n    );\n  }\n\n  assign(Builder.prototype, { [methodName]: fn });\n};\n\n// Sub-builder for onConflict clauses\nclass OnConflictBuilder {\n  constructor(builder, columns) {\n    this.builder = builder;\n    this._columns = columns;\n  }\n\n  // Sets insert query to ignore conflicts\n  ignore() {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.ignore = true;\n    return this.builder;\n  }\n\n  // Sets insert query to update on conflict\n  merge(updates) {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.merge = { updates };\n    return this.builder;\n  }\n\n  // Prevent\n  then() {\n    throw new Error(\n      'Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()'\n    );\n  }\n}\n\nmodule.exports = Builder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}